\begin{apendicesenv}

\partapendices

\chapter{Primeiro Apêndice}

Esse apêndice diz respeito aos códigos feitos na plataforma MATLAB.

\section{Código do Procedimento 1}
\label{sec:codigo_procedimento_1}
\begin{lstlisting}
% get total seconds of time to mensure the length of music 
signal = signal(:,1);
time_seconds_total = fix((length(signal)/fs)); 

% preparing struct to allocate notes in time
set_of_notes_time = {};
for set = 1:5
    notes_time(time_seconds_total, 60) = 0;
    set_of_notes_time{set} = notes_time;
end
\end{lstlisting}

\section{Código do Procedimento 2}
\label{sec:codigo_procedimento_2}
\begin{lstlisting}

function set_of_windows_signals = build_window_short_fft(signal, time, fs)
	signal = [signal(:)];

    % part A
    time_start_A = round(1+((time-1)*fs));
    time_end_A = round(time*fs);
    signal_time_A = signal(time_start_A:time_end_A);
    signal_time_A = blackman(length(signal_time_A)).*signal_time_A;

    % part B (displacement = + 0.2 seconds)
    time_start_B = round(1+((time-1)*fs+0.2*fs));
    time_end_B = round((time+0.2)*fs);
    if time_start_B < length(signal) && time_end_B <= length(signal)
        signal_time_B = signal(time_start_B:time_end_B);
        signal_time_B = blackman(length(signal_time_B)).*signal_time_B;
    else
        signal_time_B(length(signal)) = 0;
    end

    % part C (displacement = + 0.4 seconds)
    time_start_C = round(1+((time-1)*fs+0.4*fs));
    time_end_C = round((time+0.4)*fs);
    if time_start_C < length(signal) && time_end_C <= length(signal)
        signal_time_C = signal(time_start_C:time_end_C);
        signal_time_C = blackman(length(signal_time_C)).*signal_time_C;
    else
        signal_time_C(length(signal)) = 0;
    end

    % part D (displacement = + 0.6 seconds)
    time_start_D = round(1+((time-1)*fs+0.6*fs));
    time_end_D = round((time+0.6)*fs);
    if time_start_D < length(signal) && time_end_D <= length(signal)
        signal_time_D = signal(time_start_D:time_end_D);
        signal_time_D = blackman(length(signal_time_D)).*signal_time_D;
    else
        signal_time_D(length(signal)) = 0;
    end

    % part E (displacement = + 0.8 seconds)
    time_start_E = round(1+((time-1)*fs+0.8*fs));
    time_end_E = round((time+0.8)*fs);
    if time_start_E < length(signal) && time_end_E <= length(signal)
        signal_time_E = signal(time_start_E:time_end_E);
        signal_time_E = blackman(length(signal_time_E)).*signal_time_E;
    else
        signal_time_E(length(signal)) = 0;
    end

    set_of_windows_signals = {};
    if length(signal_time_A) == length(signal_time_B) && ...
        length(signal_time_A) == length(signal_time_C) && ...
         length(signal_time_A) == length(signal_time_D) &&  ...
          length(signal_time_A) == length(signal_time_E)
        set_of_windows_signals{1} = signal_time_A;
        set_of_windows_signals{2} = signal_time_B;
        set_of_windows_signals{3} = signal_time_C;
        set_of_windows_signals{4} = signal_time_D;
        set_of_windows_signals{5} = signal_time_E;
    else
        set_of_windows_signals{1} = signal_time_A;
        set_of_windows_signals{2} = signal_time_A;
        set_of_windows_signals{3} = signal_time_A;
        set_of_windows_signals{4} = signal_time_A;
        set_of_windows_signals{5} = signal_time_A;
    end
\end{lstlisting}

\section{Código do Procedimento 3}
\label{sec:codigo_procedimento_3}
\begin{lstlisting}
% get frequency spectrum
function set_of_spectrums = get_frequency_spectrum( ...
set_of_windows_signals, sampling)

    % allocate struct to spectrum
    set_of_spectrums = {};
    sampling = sampling/21;

    for part_signal_iterator = 1:5
    	% make downsample to put frequency max in 1050 Hz
        signal = downsample(set_of_windows_signals{ ...
part_signal_iterator}, 21);
        % doing fourier transform
        frequencies=(0:length(signal)-1)*sampling/length(signal);
        module_fft = abs(fft(signal));
        f_round = round(frequencies);
        frequencies_energy(max(f_round)) = 0;
        for slot = 2:length(f_round)
            frequencies_energy(f_round(slot)) = module_fft(slot);
        end
        frequency_spectrum_part = frequencies_energy(1:fix(end/2));
        set_of_spectrums{part_signal_iterator} = frequency_spectrum_part;
    end
\end{lstlisting}

\section{Código do procedimento 4}
\label{sec:codigo_procedimento_4}
\begin{lstlisting}
function set_of_notes_time = get_energy_notes(set_of_spectrums, ...
set_of_notes_time, time)
	
	% load data notes
	load_notes;

	for set = 1:5
		respfreq = set_of_spectrums{set};
		notes_time = set_of_notes_time{set};

		% this case works in one case
		respfreq = [respfreq zeros(1, length(notes(1,:)) - ...
length(respfreq))];
		for note = 1:60
	        notes_time(time, note) = sum((respfreq.*notes(note,:)).^2);    
		end	

		set_of_notes_time{set} = notes_time;
	end
\end{lstlisting}

\section{Código do procedimento 5}
\label{sec:codigo_procedimento_5}
\begin{lstlisting}
% binarize set of notes
    for set = 1:5
        notes_time = set_of_notes_time{set};
        
        for time = 1:time_seconds_total
            for note = 1:60
                if notes_time(time, note) < max(max(notes_time))/180
                    notes_time(time, note) = 0;
                else
                    notes_time(time, note) = 1;
                end
            end
        end

        set_of_notes_time{set} = notes_time;
    end
\end{lstlisting}

\section{Código do procedimento 6}
\label{sec:codigo_procedimento_6}
\begin{lstlisting}
function bass_time = get_bass(set_of_notes_time)

	notes_time_A = set_of_notes_time{1};
	notes_time_B = set_of_notes_time{2};
	notes_time_C = set_of_notes_time{3};
	notes_time_D = set_of_notes_time{4};
	notes_time_E = set_of_notes_time{5};

	total_seconds = length(notes_time_A(:,1));
	notes_time(total_seconds, 60) = 0;
	for time = 1:total_seconds
		for note = 1:60
			notes_to_analyse = [notes_time_A(time, note) ...
			 notes_time_B(time, note) ...
		 notes_time_C(time, note) ...
		  notes_time_D(time, note) ...
		   notes_time_E(time, note)];
			notes_time(time, note) = mode(notes_to_analyse);
		end
	end

    bass_time(1:total_seconds) = 0;
	for time = 1:total_seconds
		maxs = find(notes_time(time,:)==max(notes_time(time,:)));
		bass_time(time) = maxs(1);
	end

	for bass = 1:length(bass_time)
		bass_time(bass) = mod(bass_time(bass) - 1, 12) + 1;
	end

end
\end{lstlisting}

\section{Código do Procedimento 7}
\label{sec:codigo_procedimento_7}
\begin{lstlisting}
function [chord_pitch, chord_pitch_number] = ...
get_chord_pitch(notes_time, time_seconds_total, chords)
    
    dictionary_chords = { 'C', 'Cm', 'Caum', 'Cdim', ...
     'C#', 'C#m', 'C#aum', 'C#dim', 'D', 'Dm', 'Daum', 'Ddim', ...
     'Eb', 'Ebm', 'Ebaum', 'Ebdim', 'E', 'Em', 'Eaum', 'Edim', ...
     'F', 'Fm', 'Faum', 'Fdim', 'F#', 'F#m', 'F#aum', 'F#dim', ...
     'G', 'Gm', 'Gaum', 'Gdim', 'G#', 'G#m', 'G#aum', 'G#dim', ...
     'A', 'Am', 'Aaum', 'Adim', 'Bb', 'Bbm', 'Bbaum', 'Bbdim', ...
     'B', 'Bm', 'Baum', 'Bdim' };

    notes_energy_total(60) = 0;
    for note = 1:60
        notes_energy_total(note) = sum([notes_time(:,note)]);
    end

    % discover tone music
    notes_energy_tone(12) = 0;
    for note = 1:12
        notes_energy_tone(note) = notes_energy_total(note) + ...
         notes_energy_total(note + 12) ...
            + notes_energy_total(note + 2*12) + ...
             notes_energy_total(note + 3*12) ...
                + notes_energy_total(note + 4*12);
    end

    % find chord tone
    load_chords_tone;
    chords_tone(48) = 0;
    for chord = 1:48
        chords_tone(chord) = sum((notes_energy_tone.* ...
             chords_tone_mask(:, chord)'.^2));
    end

    chord_pitch_number = find(chords_tone==max(chords_tone));
    chord_pitch = dictionary_chords{chord_pitch_number};

\end{lstlisting}

\section{Código do Procedimento 8}
\label{sec:codigo_procedimento_8}
\begin{lstlisting}
function set_of_chords_time = get_set_of_chords_time(set_of_notes_time)
    load_chords_tone;

    set_of_chords_time = {};
    for set = 1:5
        notes_time = set_of_notes_time{set};
        time_total = length(notes_time(:,1));
        chords_time(1:time_total) = 0;

        for time = 1:time_total
            
            notes_energy_tone(12) = 0;
            for note = 1:12
                notes_energy_tone(note) = notes_time(time, note) + ... 
                notes_time(time, note + 12) ...
                    + notes_time(time, note + 2*12) + ...
                     notes_time(time, note + 3*12) ...
                        + notes_time(time, note + 4*12);
            end

            energy_chords(1:48) = 0;
            for chord = 1:48
                energy_chords(chord) = sum((notes_energy_tone.* ...
                        chords_tone_mask(:, chord)').^2);
            end
            
            max_chord = find(energy_chords==max(energy_chords));

            chords_time(time) = max_chord(1);
        end

        set_of_chords_time{set} = chords_time;
    end
end
\end{lstlisting}

\section{Código do Procedimento 9}
\label{sec:codigo_procedimento_9}
\begin{lstlisting}
function chords = analyse_set_of_chords(set_of_chords)

    set_of_chords_A = set_of_chords{1};
    set_of_chords_B = set_of_chords{2};
    set_of_chords_C = set_of_chords{3};
    set_of_chords_D = set_of_chords{4};
    set_of_chords_E = set_of_chords{5};

    total_seconds = length(set_of_chords_A);
    chords(1:total_seconds) = 0;
    for time = 1:total_seconds
        chords_to_analyse = [set_of_chords_A(time) ...
         set_of_chords_B(time) ...
         set_of_chords_C(time) set_of_chords_D(time) ...
          set_of_chords_E(time)];
        chords(time) = mode(chords_to_analyse);
    end
end
\end{lstlisting}

\section{Código do procedimento 10}
\label{sec:codigo_procedimento_10}
\begin{lstlisting}
function chords_with_bass = get_chords_bass(chords_number, bass_time)

 load_dictionary_chords;

 % build chords with bass to translate to dictionary
 chords_with_bass_number = {};
 chord_iterator = 1;
 for chord = 1:48
    for bass = 1:12
        chords_with_bass_number{chord_iterator} = [chord, bass];
        chord_iterator = chord_iterator + 1;
    end
 end

 %---------------------------------------------------------
 chords_with_bass = {};
 for time = 1:length(chords_number)
     for chord = 1:length(chords_with_bass_number)
        peer_chord = chords_with_bass_number{chord};
        if peer_chord(1) == chords_number(time) && ... 
            peer_chord(2) == bass_time(time)
            chords_with_bass{time} = dictionary_chords{chord};
        end
     end
 end

end
\end{lstlisting}


\end{apendicesenv}

